#!/usr/bin/env python3.8
# @generated by pegen from src/ossify/phild.gram

import ast
import sys
import tokenize
from typing import Any, Optional

from ossify.grammar import (Definition, ScopeDefinition, ScopeName, breakp,
                            cause_error, combine_strings, merge_tokens)
from pegen.parser import Parser, logger, memoize, memoize_left_rec


class GeneratedParser(Parser):
    @memoize
    def start(self) -> Optional[Any]:
        # start: scope_contents $
        mark = self.mark()
        cut = False
        if (scope_contents := self.scope_contents()) and (
            endmarker := self.expect("ENDMARKER")
        ):
            return [scope_contents, endmarker]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def scope_contents(self) -> Optional[Any]:
        # scope_contents: scope_entry+
        mark = self.mark()
        cut = False
        if _loop1_1 := self._loop1_1():
            return [_loop1_1]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def scope_entry(self) -> Optional[Any]:
        # scope_entry: scope | definition
        mark = self.mark()
        cut = False
        if scope := self.scope():
            return [scope]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if definition := self.definition():
            return [definition]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def scope(self) -> Optional[Any]:
        # scope: '{' | scope_name NEWLINE* scope_options NEWLINE* '{' NEWLINE* scope_contents NEWLINE* '}'
        mark = self.mark()
        cut = False
        if tok := self.expect("{"):
            return cause_error("Not allowed to declare anonymous scope", tok)
        self.reset(mark)
        if cut:
            return None
        cut = False
        if (
            (scope_name := self.scope_name())
            and (_loop0_2 := self._loop0_2(),)
            and (scope_options := self.scope_options())
            and (_loop0_3 := self._loop0_3(),)
            and (literal := self.expect("{"))
            and (_loop0_4 := self._loop0_4(),)
            and (scope_contents := self.scope_contents())
            and (_loop0_5 := self._loop0_5(),)
            and (literal_1 := self.expect("}"))
        ):
            return [
                scope_name,
                _loop0_2,
                scope_options,
                _loop0_3,
                literal,
                _loop0_4,
                scope_contents,
                _loop0_5,
                literal_1,
            ]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize_left_rec
    def scope_name(self) -> Optional[Any]:
        # scope_name: scope_name "." NAME | NAME
        mark = self.mark()
        cut = False
        if (
            (scope_name := self.scope_name())
            and (literal := self.expect("."))
            and (name := self.name())
        ):
            return ScopeName(scope_name.parts + [name.string])
        self.reset(mark)
        if cut:
            return None
        cut = False
        if name := self.name():
            return ScopeName([name.string])
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def definition(self) -> Optional[Any]:
        # definition: scope_name '=' valueexpr NEWLINE [scope_options NEWLINE]
        mark = self.mark()
        cut = False
        if (
            (scope_name := self.scope_name())
            and (literal := self.expect("="))
            and (valueexpr := self.valueexpr())
            and (newline := self.expect("NEWLINE"))
            and (opt := self._tmp_6(),)
        ):
            return Definition(scope_name, "values", opt)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize_left_rec
    def scope_options(self) -> Optional[Any]:
        # scope_options: scope_options NEWLINE? scope_option | scope_option
        mark = self.mark()
        cut = False
        if (
            (scope_options := self.scope_options())
            and (opt := self.expect("NEWLINE"),)
            and (scope_option := self.scope_option())
        ):
            return {**scope_options, **scope_option}
        self.reset(mark)
        if cut:
            return None
        cut = False
        if scope_option := self.scope_option():
            return scope_option
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def scope_option(self) -> Optional[Any]:
        # scope_option: "." option_keyword '=' valueexpr
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect("."))
            and (option_keyword := self.option_keyword())
            and (literal_1 := self.expect("="))
            and (valueexpr := self.valueexpr())
        ):
            return {option_keyword[0].string: valueexpr}
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize_left_rec
    def valueexpr(self) -> Optional[Any]:
        # valueexpr: valueexpr NEWLINE STRING valueexpr? | valueexpr value | value
        mark = self.mark()
        cut = False
        if (
            (valueexpr := self.valueexpr())
            and (newline := self.expect("NEWLINE"))
            and (string := self.string())
            and (opt := self.valueexpr(),)
        ):
            return [*valueexpr, string, *(opt or [])]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if (valueexpr := self.valueexpr()) and (value := self.value()):
            return valueexpr + [value]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if value := self.value():
            return value
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def value(self) -> Optional[Any]:
        # value: STRING | NUMBER | NAME | '{' | OP
        mark = self.mark()
        cut = False
        if string := self.string():
            return [string]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if number := self.number():
            return [number]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if name := self.name():
            return [name]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if tok := self.expect("{"):
            return cause_error(
                'Cannot declare scope inline with value. Use quotes "{" to escape', tok
            )
        self.reset(mark)
        if cut:
            return None
        cut = False
        if op := self.op():
            return [op]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def option_keyword(self) -> Optional[Any]:
        # option_keyword: 'help' | 'caption' | 'short_caption' | 'optional' | 'type' | 'multiple' | 'input_size' | 'style' | 'expert_level' | NAME
        mark = self.mark()
        cut = False
        if literal := self.expect("help"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("caption"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("short_caption"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("optional"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("type"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("multiple"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("input_size"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("style"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if literal := self.expect("expert_level"):
            return [literal]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if name := self.name():
            return cause_error(f"Unknown option parameter {name.string}", name)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _loop1_1(self) -> Optional[Any]:
        # _loop1_1: scope_entry
        mark = self.mark()
        children = []
        cut = False
        while scope_entry := self.scope_entry():
            children.append([scope_entry])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _loop0_2(self) -> Optional[Any]:
        # _loop0_2: NEWLINE
        mark = self.mark()
        children = []
        cut = False
        while newline := self.expect("NEWLINE"):
            children.append([newline])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: NEWLINE
        mark = self.mark()
        children = []
        cut = False
        while newline := self.expect("NEWLINE"):
            children.append([newline])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: NEWLINE
        mark = self.mark()
        children = []
        cut = False
        while newline := self.expect("NEWLINE"):
            children.append([newline])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _loop0_5(self) -> Optional[Any]:
        # _loop0_5: NEWLINE
        mark = self.mark()
        children = []
        cut = False
        while newline := self.expect("NEWLINE"):
            children.append([newline])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _tmp_6(self) -> Optional[Any]:
        # _tmp_6: scope_options NEWLINE
        mark = self.mark()
        cut = False
        if (scope_options := self.scope_options()) and (
            newline := self.expect("NEWLINE")
        ):
            return [scope_options, newline]
        self.reset(mark)
        if cut:
            return None
        return None


if __name__ == "__main__":
    from pegen.parser import simple_parser_main

    simple_parser_main(GeneratedParser)
