#!/usr/bin/env python3.8
# @generated by pegen from phild.gram

import ast
import sys
import tokenize
from typing import Any, Optional

from ossify.grammar import (
    ScopeDefinition,
    ScopeName,
    breakp,
    combine_strings,
    merge_tokens,
)
from pegen.parser import Parser, logger, memoize, memoize_left_rec


class GeneratedParser(Parser):
    @memoize
    def start(self) -> Optional[Any]:
        # start: definitions $
        mark = self.mark()
        cut = False
        if (definitions := self.definitions()) and (
            endmarker := self.expect("ENDMARKER")
        ):
            return definitions
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def definitions(self) -> Optional[Any]:
        # definitions: ((scope_definition NEWLINE?))*
        # nullable=True
        mark = self.mark()
        cut = False
        if (_loop0_1 := self._loop0_1(),):
            return [_loop0_1]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def scope_definition(self) -> Optional[Any]:
        # scope_definition: scope_node_definition NEWLINE? '{' definitions '}' | scope_node_definition
        mark = self.mark()
        cut = False
        if (
            (scope_node_definition := self.scope_node_definition())
            and (opt := self.expect("NEWLINE"),)
            and (literal := self.expect("{"))
            and (definitions := self.definitions())
            and (literal_1 := self.expect("}"))
        ):
            return [scope_node_definition, opt, literal, definitions, literal_1]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if scope_node_definition := self.scope_node_definition():
            return [scope_node_definition]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def scope_node_definition(self) -> Optional[Any]:
        # scope_node_definition: scope_name [('=' expr)] NEWLINE? scope_options?
        mark = self.mark()
        cut = False
        if (
            (scope_name := self.scope_name())
            and (expr := self._tmp_2(),)
            and (opt := self.expect("NEWLINE"),)
            and (opts := self.scope_options(),)
        ):
            return ScopeDefinition(scope_name, expr, opts)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize_left_rec
    def scope_name(self) -> Optional[Any]:
        # scope_name: scope_name "." NAME | NAME
        mark = self.mark()
        cut = False
        if (
            (scope_name := self.scope_name())
            and (literal := self.expect("."))
            and (name := self.name())
        ):
            return ScopeName(scope_name.parts + [name.string])
        self.reset(mark)
        if cut:
            return None
        cut = False
        if name := self.name():
            return ScopeName([name.string])
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize_left_rec
    def scope_options(self) -> Optional[Any]:
        # scope_options: scope_options NEWLINE? scope_option | scope_option
        mark = self.mark()
        cut = False
        if (
            (scope_options := self.scope_options())
            and (opt := self.expect("NEWLINE"),)
            and (scope_option := self.scope_option())
        ):
            return {**scope_options, **scope_option}
        self.reset(mark)
        if cut:
            return None
        cut = False
        if scope_option := self.scope_option():
            return scope_option
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def scope_option(self) -> Optional[Any]:
        # scope_option: "." NAME '=' expr
        mark = self.mark()
        cut = False
        if (
            (literal := self.expect("."))
            and (name := self.name())
            and (literal_1 := self.expect("="))
            and (expr := self.expr())
        ):
            return {name.string: expr}
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def expr(self) -> Optional[Any]:
        # expr: type_call | multiline_string | ((NAME | NUMBER | OP))+
        mark = self.mark()
        cut = False
        if type_call := self.type_call():
            return [type_call]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if multiline_string := self.multiline_string():
            return [multiline_string]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if tok := self._loop1_3():
            return merge_tokens(tok)
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize_left_rec
    def multiline_string(self) -> Optional[Any]:
        # multiline_string: multiline_string NEWLINE? STRING | STRING
        mark = self.mark()
        cut = False
        if (
            (multiline_string := self.multiline_string())
            and (opt := self.expect("NEWLINE"),)
            and (string := self.string())
        ):
            return repr(multiline_string[1:-1] + "\n" + string.string[1:-1])
        self.reset(mark)
        if cut:
            return None
        cut = False
        if string := self.string():
            return string.string
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def type_call(self) -> Optional[Any]:
        # type_call: NAME '(' function_params ')'
        mark = self.mark()
        cut = False
        if (
            (name := self.name())
            and (literal := self.expect("("))
            and (function_params := self.function_params())
            and (literal_1 := self.expect(")"))
        ):
            return [name, literal, function_params, literal_1]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def function_params(self) -> Optional[Any]:
        # function_params: function_argument ((',' function_argument))+
        mark = self.mark()
        cut = False
        if (function_argument := self.function_argument()) and (
            _loop1_4 := self._loop1_4()
        ):
            return [function_argument, _loop1_4]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def function_argument(self) -> Optional[Any]:
        # function_argument: [NAME '='] (STRING | NAME | NUMBER)
        mark = self.mark()
        cut = False
        if (opt := self._tmp_5(),) and (_tmp_6 := self._tmp_6()):
            return [opt, _tmp_6]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: (scope_definition NEWLINE?)
        mark = self.mark()
        children = []
        cut = False
        while _tmp_7 := self._tmp_7():
            children.append([_tmp_7])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: '=' expr
        mark = self.mark()
        cut = False
        if (literal := self.expect("=")) and (expr := self.expr()):
            return expr
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _loop1_3(self) -> Optional[Any]:
        # _loop1_3: (NAME | NUMBER | OP)
        mark = self.mark()
        children = []
        cut = False
        while _tmp_8 := self._tmp_8():
            children.append([_tmp_8])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _loop1_4(self) -> Optional[Any]:
        # _loop1_4: (',' function_argument)
        mark = self.mark()
        children = []
        cut = False
        while _tmp_9 := self._tmp_9():
            children.append([_tmp_9])
            mark = self.mark()
        self.reset(mark)
        if cut:
            return None
        return children

    @memoize
    def _tmp_5(self) -> Optional[Any]:
        # _tmp_5: NAME '='
        mark = self.mark()
        cut = False
        if (name := self.name()) and (literal := self.expect("=")):
            return [name, literal]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _tmp_6(self) -> Optional[Any]:
        # _tmp_6: STRING | NAME | NUMBER
        mark = self.mark()
        cut = False
        if string := self.string():
            return [string]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if name := self.name():
            return [name]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if number := self.number():
            return [number]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _tmp_7(self) -> Optional[Any]:
        # _tmp_7: scope_definition NEWLINE?
        mark = self.mark()
        cut = False
        if (scope_definition := self.scope_definition()) and (
            opt := self.expect("NEWLINE"),
        ):
            return scope_definition
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _tmp_8(self) -> Optional[Any]:
        # _tmp_8: NAME | NUMBER | OP
        mark = self.mark()
        cut = False
        if name := self.name():
            return [name]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if number := self.number():
            return [number]
        self.reset(mark)
        if cut:
            return None
        cut = False
        if op := self.op():
            return [op]
        self.reset(mark)
        if cut:
            return None
        return None

    @memoize
    def _tmp_9(self) -> Optional[Any]:
        # _tmp_9: ',' function_argument
        mark = self.mark()
        cut = False
        if (literal := self.expect(",")) and (
            function_argument := self.function_argument()
        ):
            return [literal, function_argument]
        self.reset(mark)
        if cut:
            return None
        return None


if __name__ == "__main__":
    from pegen.parser import simple_parser_main

    simple_parser_main(GeneratedParser)
