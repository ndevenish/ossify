
start = scope_contents $;

scope_contents = {scope_entry}+ ;

scope_entry =
    | definition
    | scope
    | include
    ;

definition = name:scope_name "=" value:valueexpr options:[scope_options];

# Doing scoping in-grammar is possible but complicated the grammar
# definition = Scoped_definition ;
# Scoped_definition =
#     | NAME DOT Scoped_definition
#     | Definition
#     ;
# Definition = NAME "=" value:valueexpr options:[scope_options];

# # Automatically extract nested definitions in-grammar
# scoped_definition:
#     | NAME s? "=" NEWLINE { cause_error(f"Missing value for {name.string}", newline) }
#     | ["!" " "?] NAME s? "=" s? valueexpr so=[div scope_options { scope_options}] end_def { Definition(name.string, valueexpr, so) }
#     | ["!" " "?] NAME "." scoped_definition { Scope(name.string, None, [scoped_definition]) }


scope = name:scope_name options:[scope_options] '{' [children+:scope_contents] '}' ;

scope_options = {scope_option}+ ;

scope_option = "." name:OPTION_KEYWORD "=" value:valueexpr ;


include =
    | "include" "scope" scope_name {scope_name}*
    | "include" ["file"] value
    ;


scope_name = l:NAME {DOT r+:NAME}* ;

# Parsing value expressions. This needs to be done in-grammar to handle
# newline and comment escaping rules that would otherwise be swallowed
# by the buffer
valueexpr = @:expanding_valueexpr [";"] ;
expanding_valueexpr =
    # A string on the lines after a value expression counts as part of it
    | expanding_valueexpr {WSNL}+ string
    # Other than above rules, a newline breaks the value
    | expanding_valueexpr !WSNL value
    | value
    ;

value =
    | string
    | VALUETOKEN
    # | /\\\n/
    ;

# value = /[^\n;{}]+/ ;


# valueexpr:
#     | valueexpr " " value_comment &NEWLINE { valueexpr }
#     | valueexpr " "* NEWLINE " "* STRING valueexpr? { [*valueexpr, string, *(opt or [])]}
#     | valueexpr value { valueexpr + [value] }
#     | value { value }

# Building blocks that don't swallow whitespace
NAME = /[A-Za-z_]\w*/ ;
DOT = /\./ ;
# Whitespace-preceeded explicit newline
WSNL = /[ \t]*\n/ ;
# A value token consumes any non-terminators until whitespace
VALUETOKEN = /[^{};\s]+/ ;

# A quoted string
string =
    | '"""' /(?:.|\n)*?[^\\]"""/
    | "'''" /(?:.|\n)*?[^\\]'''/
    | "'" /(?:.|\n)*?[^\\]'/
    | '"' /(?:.|\n)*?[^\\]"/
    ;

OPTION_KEYWORD =
    | 'help'
    | 'caption'
    | 'short_caption'
    | 'optional'
    | 'multiple'
    | 'style'
    | 'expert_level'
    | 'alias'
    # These only happen on definitions
    | 'type'
    | 'input_size'
    | 'deprecated'
    # These only happen on scopes
    | 'call' # (?)
    | 'sequential_format'
    | 'disable_add'
    | 'disable_delete'
    | bad_option_keyword
    ;

# Error handling
bad_option_keyword= NAME;
