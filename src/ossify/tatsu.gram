@@grammar :: PHIL
@@eol_comments :: /#.*?$/

start = scope_contents $;

scope_contents = {scope_entry}+ ;

scope_entry =
    | definition
    | scope
    | include
    ;

definition =
    | ["!"] bad_definition_assignment
    | ["!"] name:scope_name "=" value:valueexpr options:[scope_options];

scope =
    | ["!"] bad_anonymous_scope
    | ["!"] name:scope_name options:[scope_options] '{' [children:scope_contents] '}' ;

scope_options = {scope_option}+ ;

scope_option = ["!"] "." name:OPTION_KEYWORD "=" value:valueexpr ;


include =
    | ["!"] "include" /.*(?=\n|\Z)/
    | ["!"] "include" "scope" scope_name {!WSNL scope_name}*
    | ["!"] "include" ["file"] value
    ;


scope_name = l:NAME {DOT r+:NAME}* ;

# Parsing value expressions. This needs to be done in-grammar to handle
# newline and comment escaping rules that would otherwise be swallowed
# by the buffer
valueexpr = @:expanding_valueexpr [";"] ;
expanding_valueexpr =
    | expanding_valueexpr VALUE_COMMENTLIKE
    | @:expanding_valueexpr VALUE_COMMENT
    # A string on the lines after a value expression counts as part of it
    | expanding_valueexpr {WSNL}+ string
    # Other than above rules, a newline breaks the value
    | expanding_valueexpr !WSNL ["\\\n"] value
    | value
    ;

value =
    | string
    | VALUETOKEN
    # | /\\\n/
    ;

# Comments in values must have a certain form
VALUE_COMMENT = / # (?:.|\n)*?(?<!\\)(?=\n|\Z)/ ;
# But things that look like comments but no space after are values
VALUE_COMMENTLIKE = /[ \t]*#[^{};\s]+/ ;

# Building blocks that don't swallow whitespace
NAME = /[A-Za-z_]\w*/ ;
DOT = /\./ ;
# Whitespace-preceeded explicit _unescaped_ newline
WSNL = /(?:[ \t]|\\\n)*\n/ ;

# A value token consumes any non-terminators until whitespace
VALUETOKEN = /[^{};\s]+/ ;

# A quoted string
string = /("""|'''|"|')(?:\\"|\\'|.|\n)*?\1/ ;

OPTION_KEYWORD =
    | 'help'
    | 'caption'
    | 'short_caption'
    | 'optional'
    | 'multiple'
    | 'style'
    | 'expert_level'
    | 'alias'
    # These only happen on definitions
    | 'type'
    | 'input_size'
    | 'deprecated'
    # These only happen on scopes
    | 'call' # (?)
    | 'sequential_format'
    | 'disable_add'
    | 'disable_delete'
    | bad_option_keyword
    ;

# Error handling
bad_option_keyword= NAME;
bad_anonymous_scope= "{";
bad_definition_assignment=
    | bad_definition_assignment_missing_value
    | bad_definition_assignment_spaced_assignment
    ;
bad_definition_assignment_spaced_assignment = scope_name {WSNL}+ "=" ;
bad_definition_assignment_missing_value = scope_name "=" WSNL ;