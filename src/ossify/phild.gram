@subheader """
from ossify.grammar import Definition, ScopeName, Scope, combine_strings, breakp, cause_error, merge_bad_multiline_string
"""

start: scope_contents ENDMARKER { Scope("<root>", None, scope_contents)}
scope_contents: NEWLINE* contents=scope_entry+ { [x[0] for x in contents] }
scope_entry:
    | scope { scope }
    | definition { definition }

scope:
    | scope_name NEWLINE* opts=[scope_options] NEWLINE* '{' NEWLINE* cont=scope_contents? NEWLINE* '}' NEWLINE* {
                Scope(scope_name, opts, cont)
            }
    | tok='{' { cause_error("Not allowed to declare anonymous scope", tok)}

scope_name: scope_name "." NAME { ScopeName(scope_name.parts + [name.string]) }
    | NAME { ScopeName([name.string]) }

definition:
    | scope_name '=' valueexpr [NEWLINE scope_options] end_def { Definition(scope_name, valueexpr, opt)}

# newline or scope end - lookahead only fails to return value so fake
end_def: NEWLINE | &'}' { True }

scope_options:
    | scope_options [NEWLINE] scope_option { {**scope_options, **scope_option} }
    | scope_option { scope_option }
# Technically the option keywords don't have to be full expressions? Until we
# are typing these, just use the generic behaviour for everything
scope_option: "." option_keyword '=' valueexpr { {option_keyword[0].string: valueexpr}}

# Values can be anything, non-string token separation means separate
# choices. Multiline strings can roll over a set of options after a
# newline, but the new line must start with a string ('a="3" "4"\n4 "3")
# or is not valid. Maybe: something that is not a name or a number?
valueexpr:
    | valueexpr NEWLINE valuestring valueexpr? { [*valueexpr, valuestring, *(opt or [])]}
    | valueexpr value { valueexpr + [value] }
    | value { value }
value:
    | STRING
    | NUMBER
    | NAME
    | tok='{' { cause_error('Cannot declare scope inline with value. Use quotes "{" to escape', tok)}
    # We need to handle the error case where a multiline string with single quotes
    | bad_python_string { merge_bad_multiline_string(bad_python_string) }
    # Anything else that isn't a scope close, handle
    | !'}' OP
# Because string can be "string" or "bad string" we test both together for
# continuations
valuestring:
    | STRING
    | bad_python_string { merge_bad_multiline_string(bad_python_string) }

# Rules for parsing a multiline string where single quote is used. This
# makes it through the tokenizer as an error state, so we should be able
# to patch something together.
# We swallow STRING values because this I believe this implies an open
# and close on the same line, so would have been expected to be part
bad_python_string:
    | '"' (STRING | NUMBER | NAME | !'"' OP | "'" | NEWLINE)+ '"'
    | "'" (STRING | NUMBER | NAME | !"'" OP | '"' | NEWLINE)+ "'"

# type_call: NAME '(' function_params ')'
# function_params: function_argument (',' function_argument)+
# function_argument: [NAME '='] (STRING | NAME | NUMBER)

# option_choice_definition:
#     | option_choice_definition ['*'] NAME
#     | ['*'] NAME


option_keyword:
    | 'help'
    | 'caption'
    | 'short_caption'
    | 'optional'
    | 'multiple'
    | 'style'
    | 'expert_level'
    # These only happen on definitions
    | 'type'
    | 'input_size'
    # These only happen on scopes
    | 'call'
    | 'sequential_format'
    | 'disable_add'
    | 'disable_delete'
    | NAME { cause_error(f"Unknown option parameter {name.string}", name) }


    # | 'caption' '='
    #     .help = "The size of the local area around the spot in which to"
    #             "calculate the mean and variance. The kernel is given as a box"
    #             "of size (2 * nx + 1, 2 * ny + 1) centred at the pixel."
    #     .caption = None
    #     .short_caption = None
    #     .optional = None
    #     .type = ints(size=2)
    #     .multiple = None
    #     .input_size = None
    #     .style = None
    #     .expert_level = 1
# include: 'include' ('scope' | 'file') (scope_name | STRING)

# definition: scope_name ['=' expr]



#name [= default_options]?
